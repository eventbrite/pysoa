pysoa
=====

A general-purpose library for writing Python services and their clients. Consists of ``server``, ``client`` and ``common`` submodules.

.. contents:: Contents
   :depth: 3
   :backlinks: none



The service API
---------------

Services in ``pysoa`` are built around a simple service API. The core abstractions of this API are jobs and actions. An action is a unit of work performed by a Server, while a job is a container of actions.

Jobs and actions are represented in code as objects with the following structures:


JobRequest
++++++++++

``control`` - A dict with the following keys, as well as any other keys required by the implementation:

+ ``switches``: A list of switch values (see below).
+ ``continue_on_error``: Tells the Server whether to continue processing the job if any action results in an error (``bool``).
+ ``correlation_id``: A unique ID that is generated by the Client and follows the job. Must be passed to any other service calls made while processing the job. Used to facilitate metrics (``str``).

``context``: A dict containing arbitrary values that do not affect the execution of the job. Generally used for metadata.

``actions``: A list containing ``ActionRequests``.


ActionRequest
+++++++++++++

``action``: The name of the action (``str``).

``body``: A dict containing arguments for the action.


JobResponse
+++++++++++

``actions``: A list of ``ActionResponses``

``errors``: A list of ``Errors``


ActionResponse
++++++++++++++

``action``: The name of the action (``str``).

``errors``: A list of ``Errors``.

``body``: A dict containing the return value of the action.


Error
+++++

``code``: A numerical error code (``int``).

``message``: A human-readable error message (``str``).

``field``: An identifier of the form ``'field.subfield'`` for the field in the ``ActionRequest`` that caused the error, if applicable (``str``).



The Server module
-----------------


Versioning using switches
+++++++++++++++++++++++++

Switches are like a special argument that every action in a job gets. In terms of code, switches are simply integers passed by the Client in the control header of every ``JobRequest``, and then by the Server into every action in that job.

Switches came from a need to version individual service actions, rather than versioning the whole service at once. To do this, implement a switching function that calls a different action depending on the switches in the ``ActionRequest``. For example::


    MY_ACTION_V2 = 1

    class MyAction(Action):
        ...

    class MyActionV2(Action):
        ...

    def my_action(action_request):
        if MY_ACTION_V2 in action_request.switches:
            return MyActionV2(action_request)
        else:
            return MyAction(action_request)



The Client module
-----------------

The ``client`` submodule provides the ``Client`` class as well as routing and plugin classes.


Client
++++++

The ``Client`` class can be used to communicate with services that are written using the ``Server`` class or that implement the same API. The ``Client`` provides a convenient interface for calling service actions, receiving responses and handling exceptions.

``Client``:

- ``service_name``: Name of the service to be called (``str``).
- ``transport``: A ``Transport`` instance.
- ``serializer``: A ``Serializer`` instance.
- ``middleware`` (optional): A list of ``ClientMiddleware`` instances (optional).


``Client.call_actions`` - Build and send a ``JobRequest`` from ``ActionRequest`` objects and control args and return an ``ActionResponse``. Args:

- ``actions``: A list of ``ActionRequests``
- ``context`` (optional): Corresponds to the ``context`` dict in ``JobRequest``.
- ``correlation_id``, ``continue_on_error`` (optional): Values that will be included in ``JobRequest.control``.
- ``control_extra`` (optional): A dict containing any extra values that will be included in ``JobRequest.control``.

``Client.call_action`` - Build and send a ``JobRequest`` from action arguments and control args and return an ``ActionResponse``. Args:

- ``action_name``: The action name (``str``).
- ``body`` (optional): A dict containing arguments for the action.
- ``correlation_id``, ``continue_on_error``, ``control_extra`` (optional): Same as in ``call_actions``.

``Client.send_request`` - Asynchronously sends a request and returns an integer request ID. Args:

- ``request``: ``JobRequest``

``Client.get_all_responses`` - Gets all outstanding requests and yields them as a generator.


Client settings format
++++++++++++++++++++++

Settings for the default ``ClientSettings`` class have the following structure::


    my_service_settings = {
        'service_name': {
            'client': {
                'path': 'path.to.my.client:MyClient',
                'kwargs': {}, # optional
            },
            'transport': {
                'path': 'path.to.my.transport:MyTransport',
                'kwargs': {'foo': 'bar'}, # optional
            },
            'serializer': {
                'path': 'path.to.my.serializer:Myserializer',
                'kwargs': {'baz': 'quas'}, # optional
            },
            'middleware': [
                ('path.to.my.middleware:MyMiddleware', {'wex': 'exort'}),
                ...
            ],
            'cacheable': False,
        },
        ...
    }

The ``client``, ``transport`` and ``serializer`` sections contain the import path and keyword arguments for ``Client``, ``Transport`` and ``Serializer`` classes, respectively. The ``middleware`` section contains a list of tuples of (import path, keyword arguments) for ``ClientMiddleware`` classes.

The ``cacheable`` parameter indicates whether the ``Client`` instance for this service should be cached by the router (see `Caching`_).

A settings dict containing multiple services must have settings for each service. In order to simplify the process, developers may wish to subclass ``ClientSettings`` to provide defaults for their services (see `Settings`_).

Router
++++++

The ``ClientRouter`` class provides a standard interface for instantiating clients for services. It takes a settings dict and provides the following interface:

``ClientRouter``:

- ``config``: A settings dict, as described in `Client settings format`_.
- ``settings_class``: A subclass of ``Settings`` that the router will use to parse the settings dict that is passed to it, as described in `Settings`_.

``ClientRouter.get_client``: Instantiate and return a ``Client`` for the provided service name. Automatically instantiates and provides transport, serializer and middleware classes to the ``Client``, based on the provided settings for the service.

- ``service_name``: Name of the service (``str``).
- ``kwargs``: Any keyword arguments provided will be passed to the ``Client`` as initialization arguments.

Caching
*******

If the service settings specify that the client is ``cacheable``, subsequent calls to ``get_client`` after the first will return the same ``Client`` instance. Be careful with caching clients that take keyword arguments, as the router will return the ``Client`` instance from the *first* call, regardless of the keyword arguments to subsequent calls.



The Common module
-----------------


Serializer
++++++++++

The ``Serializer`` class allows Clients and Servers to communicate using a common format. This library provides serializer classes for the JSON and msgpack formats, and the base ``Serializer`` class can be extended to use any format that a developer may wish to use. The ``Serializer`` interface is simple:

``Serializer``:

- ``mime_type``: A unique string that identifies the type of serializer used to encode a message. Generally of the form ``application/format`` where ``format`` is the lower-case alphanumeric name of the message format.

``Serializer.dict_to_blob``: Takes a Python dictionary and serializes it to a binary string.

``Serializer.blob_to_dict``: Takes a binary string and deserializes it to a Python dictionary.

Serializer exceptions
*********************

``InvalidField``: Raised when the serializer fails to serialize a message. Contains the arguments from the original exception raised by the serialization backend's encoding function.

``InvalidMessage``: Raised when the serializer fails to deserialize a message. Contains the arguments from the original exception raised by the serialization backend's decoding function.

Serializer subclasses
*********************

Different serializer classes may behave slightly differently depending on the message format that they use. The provided serializer classes have the following behavior:

``MsgpackSerializer``:

- Backend: `msgpack-python <https://pypi.python.org/pypi/msgpack-python>`_
- Types supported: ``int``, ``str``, ``dict``, ``list``, ``tuple``, ``bytes`` (Python 3 only)
- Other notes: Makes no distinction between ``list`` and ``tuple`` types. Both types will be deserialized as lists.

``JSONSerializer``:

- Backend: `json <https://docs.python.org/2/library/json.html>`_
- Types supported: ``int``, ``str``, ``dict``, ``list``, ``tuple``
- Other notes: Makes no distinction between ``list`` and ``tuple`` types. Both types will be deserialized as lists.


Transport
+++++++++

The ``transport`` module provides an interface for sending messages between clients and servers. There are two base classes:

``CilentTransport``:

- ``service_name``: The name of the service that the transport is for.

``ClientTransport.send_request_message``: Send a serialized request to a server.

- ``request_id``: The ID of the request being sent. This is provided by the client and must be returned with the response, to allow the client to keep track of message order.
- ``meta``: A dictionary containing any metadata required for the server to process the message and return a response. At a minimum, includes the mime type of the serializer used to encode the message so that the server can decode it and correctly encode the response.
- ``message_string``: The raw message, as encoded by the serializer's ``dict_to_blob`` method.

``ClientTransport.receive_response_message``: Returns a tuple of (``request_id``, ``response_message_string``).


``ServerTransport``:

- ``service_name``: The name of the service that the transport is for.

``ServerTransport.receive_request_message``: Return a tuple of (``request_id``, ``meta``, ``request_message_string``).

``ServerTransport.send_response_message``: Send a serialized request to the client that sent the response.

- ``request_id``: The ID of the request corresponding to the response being sent. This is provided by ``receive_request_message``.
- ``meta``: The same ``meta`` sent by ``ClientTransport.send_request_message``.
- ``message_string``: The raw message, as encoded by the serializer's ``dict_to_blob`` method.

Transport exceptions
********************

``InvalidMessageError``: The transport tried to send or receive a message that was malformed.

``MessageTooLarge``: The message passed to the transport exceeded the maximum size allowed by the transport.

``ConnectionError``: The transport failed to connect to its message backend.

``MessageSendTimeout``: The transport timed out while trying to send a message.

``MessageSendError``: The transport encountered any other error while trying to send a message.

``MessageReceiveTimeout``: The transport timed out while waiting to receive a message.

``MessageReceiveError``: The transport encountered any other error while trying to receive a message.


ASGI Transport
**************

The ``transport.asgi`` module provides a transport implementation that uses `ASGI <http://channels.readthedocs.io/en/stable/asgi.html>`_. This is the recommended transport for use with ``pysoa``, as it provides a convenient and performant backend for asynchronous service requests. It is also the technology underlying `Django channels <https://channels.readthedocs.io/en/stable/>`_, so you know it's good.

The reference ASGI implementation, used in ``transport.asgi``, uses Redis as a message backend, so it has the important limitation of needing access to a Redis server in order to function. If you need to use a different backend, you can implement your own ``ASGITransportCore`` or extend the existing one.

Configuration
~~~~~~~~~~~~~

The ASGI transports take the following extra keyword arguments for configuration:

- ``asgi_channel_type``: Specifies the type of channel to be used by the ASGI backend. There are three options: ``ASGI_CHANNEL_TYPE_LOCAL``, ``ASGI_CHANNEL_TYPE_REDIS_SENTINEL`` and ``ASGI_CHANNEL_TYPE_REDIS``. The Redis backend types are intended for production use, while the local type is intended primarily for testing.

- ``asgi_channel_redis_host`` (optional): If ``ASGI_CHANNEL_TYPE_REDIS`` is set, specifies the Redis host that the transport will use as a backend. If ``ASGI_CHANNEL_TYPE_REDIS_SENTINEL`` is set, the transport will connect to this host and use it to get configuration for the Sentinel master, then connect to the master. Not required for local channels.

- ``asgi_channel_redis_port`` (optional): The port that the transport will use to connect to Redis. Not required for local channels. Defaults to 6379.

- ``asgi_channel_redis_db`` (optional): The Redis database (an integer) that the transport will connect to. Not required for local channels. Defaults to 0.

- ``channel_full_retries`` (optional): Number of times the transport will retry sending a message when the channel is full. Defaults to 10.


Settings
++++++++

The ``settings`` module provides classes that contain settings for clients and servers. The ``Settings`` class wraps a dictionary with convenience methods to manage defaults and resolve import paths.


The ``Settings`` class
**********************

``Settings`` is the base class for settings, from which all other settings classes inherit. It has three primary functions: schema validation, defaults and import resolution.

- Schema validation: Settings performs validation on input values using `conformity <https://github.com/eventbrite/conformity>`_. Subclasses merge their schema with that of their parents, to a depth of 1.

- Defaults: Subclasses may define defaults as a dictionary. Defaults defined on a subclass will be merged with the defaults of its parent, to a depth of 1. For example::

    class BaseSettings(Settings):
        schema = {
            'foo': conformity.fields.Integer(),
            'bar': conformity.fields.SchemalessDictionary(key_type=conformity.fields.UnicodeString()),
        }
        defaults = {
            'foo': 1,
            'bar': {'baz': 2},
        }

    class MySettings(BaseSettings):
        defaults = {
            'bar': {'quas': 3}
        }

  The class MySettings will have the defaults ``{'foo': 1, 'bar': {'quas': 3}}``. This provides a measure of convenience while discouraging deep inheritance structures.

  When a ``Settings`` instance is created, the provided dictionary of values is merged recursively with the class's defaults::

    my_settings = MySettings({'bar': {'some_setting': 42}})
    my_settings['foo']
    > 1
    my_settings['bar']['quas']
    > 3
    my_settings['bar']['some_setting']
    > 42

- Import resolution: Settings classes may define methods to resolve import paths to objects. For each key in its input value, a ``Settings`` object will check to see if it has a method called ``convert_<key>``, and will call it with the corresponding value. For example::

    class FooSettings(Settings):
        schema = {
            'serializer': conformity.fields.Dictionary({
                'path': conformity.fields.UnicodeString(),
            }),
        }

        def convert_serializer(self, value):
            if "object" not in value:
                try:
                    value["object"] = self.resolve_python_path(value["path"])
                except ImportError:
                    raise self.ImproperlyConfigured(
                        "Could not resolve path '{}' for configuration:\n{}".format(value["path"], value))
            return value

    my_settings = FooSettings({
        'serializer': {
            'path': 'pysoa.common.serializer:JSONSerializer'
        }
    })

    my_settings['serializer']['object']
    > pysoa.common.serializer.json_serializer.JSONSerializer

  The method ``resolve_python_path`` takes care of the import for you. The ``Settings`` class also provides a convenience method called ``standard_convert_path`` that converts a value exactly as above, so ``convert_serializer`` could simply be written as::

    def convert_serializer(self, value):
        return self.standard_convert_path(value)


Settings subclasses
*******************

``common.settings.SOASettings``:

- Schema:

  + ``transport``: Import path and keyword args for a ``Transport`` class.

  + ``serializer``: Import path and keyword args for a ``Serializer`` class.

  + ``middleware``: List of 2-tuples, each containing a path and a dict of keyword args for a ``ClientMiddleware`` or ``ServerMiddleware`` class.

Both the ``client`` and ``server`` modules implement their own subclasses that inherit from ``SOASettings``. Developers implementing ``Client`` or ``Server`` subclasses may wish to subclass the respective settings class in order to alter or extend the schema or defaults.

